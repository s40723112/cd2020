<h1>About</h1>
<p>此內容管理系統以 <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 作為 submodule 運作, 可以選定對應的版本運作, cmsimde 可以持續改版, 不會影響之前設為 submodule, 使用舊版 cmsimde 模組的內容管理相關運作.</p>
<h4>利用 cmsimde 建立靜態網誌方法:</h4>
<p>1. 在 github 建立倉儲, git clone 到近端</p>
<p>2. 參考 <a href="https://github.com/mdecourse/newcms">https://github.com/mdecourse/newcms</a>, 加入除了 cmsimde 目錄外的所有內容</p>
<p>以 git submodule add <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> cmsimde</p>
<p>建立 cmsimde 目錄, 並從 github 取下子模組內容.</p>
<p>3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器.</p>
<p>動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端.</p>
<p>4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行:</p>
<p>git clone --recurse-submodules <a href="https://github.com/mdecourse/newcms.git">https://github.com/mdecourse/newcms.git</a></p>
<h1>Develop</h1>
<p><a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443 就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容.</p>
<p>cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版.</p>
<p>init.py 位於  up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數.</p>
<h1>Week</h1>
<h3>week 2</h3>
<h4>將python 3.7.3更新至3.8.2</h4>
<p>1.進入<a href="https://www.python.org/downloads/release/python-382/">https://www.python.org/downloads/release/python-382/</a> </p>
<p>2.往下滑到最底，下載<a href="https://www.python.org/ftp/python/3.8.2/python-3.8.2-amd64.exe">Windows x86-64 executable installer</a></p>
<p>3.下載完成後開啟，選擇Customize installation選項</p>
<p><img alt="../_images/win_installer.png" height="258" src="https://docs.python.org/zh-tw/3/_images/win_installer.png" width="406"/></p>
<p>(請不要在意版本號)</p>
<p>4.不要勾選pip選項，接著按下next</p>
<p>5.選擇路徑將python安裝至可攜式系統中的Y槽下</p>
<p>6.接著開啟start_mdecourse.bat批次檔</p>
<p>7.將<span>start_mdecourse.bat批次檔中的py373改為安裝python 3.8.2版本的資料夾</span></p>
<p><span>(我的資料夾名字是py382)</span></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">@echo off
set Disk=y
subst %Disk%: "data"

%Disk%:

set HomePath=%Disk%:\home_mdecourse
set HomeDrive=%Disk%:\home_mdecourse
set Home=%Disk%:\home_mdecourse
set USERPROFILE=%Disk%:\home_mdecourse

REM 將系統 Python 程式的 io 設為 utf-8
set PYTHONIOENCODING="utf-8"

set PYTHONPATH=%Disk%:\\DLLs;%Disk%:\py382\Lib;%Disk%:\py382\Lib\site-packages;
set PYTHONHOME=%Disk%:\py382

set path_python=%Disk%:\py382;%Disk%:\py382\Scripts;
set path_msys2=%Disk%:\msys64\mingw64\bin;
REM coreutils is for compiling fossil scm
set path_coreutils=%Disk%:\coreutils-5.3.0\bin;%Disk%:\depends22_x64;
set path_tcc=%Disk%:\tcc;
set path_cmake=%Disk%:\cmake-3.10.1-win64-x64\bin;
set path_nodejs=Disk%:\nodejs;%Disk%:\nodejs\appdata\roaming\npm;
set path_git=%Disk%:\portablegit\bin;
set path_xming=%Disk%:\Xming;
set path_latex=%%Disk%:\Pandoc;%Disk%:\TinyTeX\bin\win32;

path=%Disk%:;%path_python%;%path_msys2%;%path_tcc%;%path_git%;%path_cmake%;%path_coreutils%;

start /MIN cmd.exe
start /MIN cmd.exe
start /MIN cmd.exe
start /MIN cmd.exe

start /MIN %Disk%:\wscite415\wscite\SciTE.exe
start /MIN %Disk%:\wscite415\wscite\SciTE.exe

Exit</pre>
<p>8.執行stop.bat批次檔後重新啟動start_mdecourse(為了讓檔案重新讀取)<br/><br/></p>
<p>9.輸入get-pip.py，開始安裝pip工具</p>
<p>10.安裝完成後，使用 pip install <em>XXX</em>(<span>packages名字</span>)，安裝以下<span>packages:</span></p>
<p><span>1.<strong>Flask</strong><br/>2.<strong>Markdown</strong><br/>3.<strong>lxml</strong><br/>4.<strong>bs4</strong><br/>5.<strong>flask_cors</strong><br/>6.<strong>pelican</strong><br/>7.<strong>leo</strong></span></p>
<p><span>EX.:要安裝Flask就輸入 <span style="color: #ff0000;">pip install Flask</span> ，以此類推<br/><br/></span></p><h2>week 4</h2>
<h4>無法執行launchleo.py</h4>
<p>當更新python為3.8.2版本並且要執行launchleo.py發現無法像之前一樣順利開啟。</p>
<p>解決方法:</p>
<p>1.開啟start.bat</p>
<p>2.進入SciTE程式編輯器，點選options</p>
<p>3.點選open python properties</p>
<p><img alt="" height="971" src="/images/未命名154.jpg" width="561"/></p>
<p>4.使用Ctrl+F  尋找<span style="color: #ff0000;"> py373 </span></p>
<p><span style="color: #000000;">5.將py373更改為可攜裝置中的python3.8.2的資料夾名稱</span></p>
<p><span style="color: #000000;">範例:</span></p>
<p><span style="color: #000000;">我的python3.8.2資料夾名稱為py382</span></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false"># Define SciTE settings for Python files.

file.patterns.py=*.py;*.pyw;*.pyx;*.pxd;*.pxi
file.patterns.scons=SConstruct;SConscript

*source.patterns.python=$(file.patterns.py);

shbang.python=py

filter.python=Python (py pyw)|$(file.patterns.py)|

*filter.python=$(filter.python)

lexer.$(file.patterns.py)=python
lexer.$(file.patterns.scons)=python

*language.python=Pytho&amp;n|py||

keywordclass.python2=and as assert break class continue def del elif \
else except exec finally for from global if import in is lambda not \
or pass print raise return try while with yield

keywordclass.python3=False None True and as assert break class continue \
def del elif else except finally for from global if import in is lambda \
nonlocal not or pass raise return try while with yield

keywordclass.python=$(keywordclass.python2)

# Extra keywords for cython
keywordclass.cython=cdef cimport cpdef

keywords.$(file.patterns.py)=$(keywordclass.python) $(keywordclass.cython)
keywords.$(file.patterns.scons)=$(keywordclass.python)

# If you uncomment the 3 lines below,
# and put some words after "keywordclass2.python=",
# those words will be styled by style.python.14

#keywordclass2.python=
#keywords2.$(file.patterns.py)=$(keywordclass2.python)
#keywords2.$(file.patterns.scons)=$(keywordclass2.python)

# Use 2 sets of substyles to highlight standard library modules and
# imports from the future.
# Additional identifier sets can be added by incrementing the  next
# line's value and adding extra definitions similar to below.
substyles.python.11=2

substylewords.11.1.$(file.patterns.py)=\
__main__ _dummy_thread _thread abc aifc argparse \
array ast asynchat asyncio asyncore atexit audioop \
base64 bdb binascii binhex bisect builtins bz2 \
calendar cgi cgitb chunk cmath cmd code codecs \
codeop collections colorsys compileall concurrent \
configparser contextlib copy copyreg crypt csv \
ctypes curses datetime dbm decimal difflib dis \
distutils dummy_threading email ensurepip enum \
errno faulthandler fcntl filecmp fileinput fnmatch \
formatter fpectl fractions ftplib functools gc getopt \
getpass gettext glob grp gzip hashlib heapq hmac \
html http http imaplib imghdr importlib inspect io \
ipaddress itertools json keyword linecache locale \
logging lzma macpath mailbox mailcap marshal math \
mimetypes mmap modulefinder msilib msvcrt \
multiprocessing netrc nis nntplib numbers operator \
os os ossaudiodev parser pathlib pdb pickle \
pickletools pipes pkgutil platform plistlib poplib posix \
pprint pty pwd py_compile pyclbr queue quopri \
random re readline reprlib resource rlcompleter runpy \
sched select selectors shelve shlex shutil signal site \
smtpd smtplib sndhdr socket socketserver spwd \
sqlite3 ssl stat statistics string stringprep struct \
subprocess sunau symbol symtable sys sysconfig \
syslog tabnanny tarfile telnetlib tempfile termios \
textwrap threading time timeit tkinter token \
tokenize trace traceback tracemalloc tty turtle \
types unicodedata unittest urllib uu uuid venv warnings \
wave weakref webbrowser winreg winsound wsgiref \
xdrlib xml xmlrpc zipfile zipimport zlib
style.python.11.1=fore:#DD9900

substylewords.11.2.$(file.patterns.py)=__future__ \
with_statement unicode_literals print_function
style.python.11.2=fore:#EE00AA,italics

#~ statement.indent.$(file.patterns.py)=10 :
statement.indent.$(file.patterns.py)=5 class def elif else except finally \
for if try while with

statement.lookback.$(file.patterns.py)=0
block.start.$(file.patterns.py)=
block.end.$(file.patterns.py)=

view.indentation.examine.*.py=2

tab.timmy.whinge.level=1

#fold.quotes.python=1

comment.block.python=#~

indent.python.colon=1

# Python styles
# White space
style.python.0=fore:#808080
# Comment
style.python.1=fore:#007F00,$(font.comment)
# Number
style.python.2=fore:#007F7F
# String
style.python.3=fore:#7F007F,$(font.monospace)
# Single quoted string
style.python.4=fore:#7F007F,$(font.monospace)
# Keyword
style.python.5=fore:#00007F,bold
# Triple quotes
style.python.6=fore:#7F0000
# Triple double quotes
style.python.7=fore:#7F0000
# Class name definition
style.python.8=fore:#0000FF,bold
# Function or method name definition
style.python.9=fore:#007F7F,bold
# Operators
style.python.10=bold
# Identifiers
style.python.11=
# Comment-blocks
style.python.12=fore:#7F7F7F
# End of line where string is not closed
style.python.13=fore:#000000,$(font.monospace),back:#E0C0E0,eolfilled
# Highlighted identifiers
style.python.14=fore:#407090
# Decorators
style.python.15=fore:#805000
# F-String
style.python.16=fore:#7F007F,$(font.monospace)
# Single quoted f-string
style.python.17=fore:#7F007F,$(font.monospace)
# Triple quoted f-string
style.python.18=fore:#7F0000
# Triple double quoted f-string
style.python.19=fore:#7F0000
# Matched Operators
style.python.34=fore:#0000FF,bold
style.python.35=fore:#FF0000,bold
# Braces are only matched in operator style
braces.python.style=10

if PLAT_WIN
	command.go.*.py=y:\py382\pythonw -u "$(FileNameExt)"
	command.go.subsystem.*.py=1
	command.go.*.pyw=pythonw -u "$(FileNameExt)"
	command.go.subsystem.*.pyw=1
	command.build.SConscript=scons.bat --up .
	command.build.SConstruct=scons.bat .

if PLAT_GTK
	command.go.*.py=y:\py382\python -u "$(FileNameExt)"
	command.build.SConscript=scons --up .
	command.build.SConstruct=scons .

if PLAT_MAC
	command.go.*.py=python -u "$(FileNameExt)"
	command.build.SConscript=scons --up .
	command.build.SConstruct=scons .

command.name.1.$(file.patterns.py)=Syntax Check
command.1.$(file.patterns.py)=python -c "import py_compile; py_compile.compile(r'$(FilePath)')"
</pre>
<p></p>
<p>將launchleo.py檔案放入SciTE編輯器就能夠順利開啟leo Editor</p><h2>Week 6</h2>
<h3>OBS</h3>
<p>下載<a href="https://portableapps.com/apps/music_video/obs-studio-portable">protable OBS</a></p>
<p><img alt="" height="346" src="/images/1542.jpg" width="708"/></p>
<p></p>
<p>OBS 設定</p>
<p><strong>螢幕擷取</strong></p>
<p><img alt="" height="457" src="/images/1545.jpg" width="652"/></p>
<p><img alt="" height="453" src="/images/werwef.jpg" width="643"/></p>
<p><img alt="" height="482" src="/images/87875.jpg" width="642"/></p>
<p></p>
<p></p>
<p><strong>將手機當作攝像頭</strong></p>
<p>PC和手機都下載 <em><a href="https://www.e2esoft.com/ivcam/">iVCam</a></em></p>
<p>下載完成使用傳輸線將手機和PC連接，PC和手機都開啟iVCam，即可使用。</p>
<p>在OBS設定中新增<strong>視訊擷取裝置</strong></p>
<p>裝置選擇iVCam</p>
<p><b><img alt="" height="533" src="/images/15453.jpg" width="722"/></b></p>
<p></p>
<p>將視訊裝置畫面放在右下角</p>
<p><img alt="" height="509" src="/images/84853.jpg" width="725"/></p>
<p><strong><em>youtube直播設定</em></strong></p>
<p>平台選擇youtube，並且要輸入自己帳號的直播金鑰</p>
<p><img alt="" height="754" src="/images/15487231.jpg" width="982"/></p><h3>翻譯</h3>
<p><strong>翻譯<a href="https://drive.google.com/file/d/13THamnfayiRT4Wa9KzmjXQSP4ZW2jIej/view?usp=sharing">MechanicalDesignProcess.pdf</a> 第二章節 Building the Design後半部(P27~P33)</strong></p>
<p><em>Footnote: (Statistical note) Some designers would make a case for some statistical probability, less than 100%, that all (4) tolerances would go in one direction, and we would not (likely) have a total of 0.025 inch. Some conservative designers would assume that all tolerance will go in the “wrong” direction, and thus，design is a “worst case.” I’ll generally disregard the “statistical” approach to tolerances for now, but it could be valuable in design situations where space is extremely constrained. See Sect. 4.8 for a discussion of:</em></p>
<ul>
<li><em> Tolerancing using sum of squares</em></li>
<li><em> Tolerancing using Monte Carlo simulation</em></li>
</ul>
<p><span> </span></p>
<p>註記<span>:(</span>統計說明<span>)</span>某些設計師會提出一些統計概率，小於<span>100</span>％，則所有（<span>4</span>）公差將沿一個方向，而且我們<span>(</span>可能<span>)</span>不會總計有<span>0.025</span>英寸。 一些保守的設計師會假設所有公差都將朝“錯誤”的方向發展，因此，設計是“最壞的情況”。 我現在通常不會理會公差的“統計”方法，但在空間非常受限的設計情況下，這可能會很有價值。 參見章節。<span> 4.8</span>討論：</p>
<ul>
<li>使用平方和進行公差</li>
<li>使用蒙特卡洛模擬進行公差</li>
</ul>
<ol start="2">
<li style="text-align: left;"><em>Movement of the Object relative to the Wall (during product operation): This is also known as “sway” clearance, that is, the object may vibrate in operation while the wall could be steadfast</em></li>
</ol>
<p style="text-align: left;"><span>2.</span>物體相對於牆壁的運動（在產品運行過程中）：這也稱為“搖擺”間隙，也就是說，物體可能在運作時振動，而牆壁可能會保持堅固。</p>
<ol start="3">
<li><em> Growth of the Objects (during operation): This could be the result of thermal expansion.</em></li>
</ol>
<p style="text-align: left;">3.物體的膨脹（在操作過程中）：這可能是熱膨脹的結果。</p>
<p><span>4<em>.Overall (outside) size constraints: Internal clearance distance will be affected by the overall size. That is, with a given overall size, the distance between objects will have some particular limit. The distance between objects will be a function on the size   tolerances of the objects and the tolerances on the Object locations. If the overall size is not constrained (rare instance), Object size and clearances between Objects will determine the overall size.</em></span></p>
<p><em>4</em>.整體（外部）尺寸限制：內部間隙距離將受到整體尺寸的影響。也就是說，對於給定的整體大小，物體之間的距離將有一些特定的限制。物體之間的距離將取決於物體的尺寸公差和物體位置的公差。如果總體尺寸不受限制（稀少例子），則物體尺寸和物體間隙之間的大小將決定整體大小。</p>
<p><em><strong>2.4.2 Object Arrangement</strong></em></p>
<p><em><strong>2.4.2物體排列</strong></em></p>
<p><em>The designer usually works to minimize the overall dimensions of the enclosure by a “productive” arrangement of all of the Objects needed to fit within the enclosure. </em></p>
<p>設計師通常會通過“生產”排列所有適合安裝在外殼中的物體的方式來最大程度地減小外殼的整體尺寸。</p>
<p><em>This can be done in two dimensions (X and Y) and the 3rd dimension, Z. Other arrangements of Objects look to fulfill assembly, servicing, aesthetic, or user interface needs.</em></p>
<p>這可以在兩個維度（<span>X</span>和<span>Y</span>）以及第三個維度<span>Z</span>中進行。物體的其他排列旨在滿足組裝，維修，美觀或用戶界面的需求。</p>
<p><em>In order to minimize the overall dimensions, some distance between Objects is chosen. This distance can be first thought of as a nominal distance.This nominal distance can then be adjusted to suit the design. For example, one could assume a nominal distance between objects of 0.100 inch (in all directions).</em></p>
<p>為了最小化整體尺寸，決定了物體之間的一定距離。 該距離可以首先被認為是公稱距離。 然後可以調整該公稱距離以適合設計。 例如，可以假設物體之間的標稱距離為<span>0.100</span>英寸（在所有方向上）。</p>
<p><em>Of course, the gap size would not have to be the same between all objects. Perhaps the 0.100 “gap” between objects produces an overall dimension that exceeds the expectations of the product (exceeds the product specification). </em></p>
<p>當然，所有物體之間的間隙大小不必相同。 物體之間的<span>0.100</span>“間隙”可能會產生超出產品期望值的總體尺寸（超出產品規格）。</p>
<p><em>Then, the designer would look to reduce the 0.100 inch gap – but, the gap cannot be less than zero, and it cannot be less thanany “worst-case” problem such as an Object being supplied at the upper end of its size tolerance or other factors explored below.</em></p>
<p><span> 然後，設計人員將尋求減少0.100英寸的間隙-但是，間隙不能小於零，也不能小於任何“最壞情況”的問題，像是在其尺寸公差的上限提供了一個物體，或者探討下面其他因素。</span></p>
<p><em>Then, the designer checks to see that all of the Objects in the enclosure have been placed and that the gaps between Objects are such that all interference between Objects is avoided under all environments and user experiences that the design will exist in. </em></p>
<p>然後，設計人員檢查是否已放置了外殼中的所有物體，並且物體之間的間隙是否能夠避免在此設計上的所有環境和用戶使用上的所有干擾。</p>
<p><em>The designer will also check to see that the Objects can be assembled into the enclosure in a “forthright” manner and that the service objectives of the product are upheld.</em></p>
<p>設計人員還將檢查是否有以“直覺”的方式將物體組裝到外殼中，以及確保產品的售後服務與維護。</p>
<p><em>The design is ready for the Design Review Process.</em></p>
<p>該設計已準備可以進行審核過程。</p>
<p><em>Reviewing, gaps between volumes (or objects) are a function of:</em></p>
<p>以下功能是查看，體積（或物體<span>)</span>之間的間隙<span>:</span></p>
<ul>
<li><em> Fabrication tolerances: A given “box” may be specified as a nominal dimension.</em></li>
</ul>
<p><em>However, a slightly larger (or smaller) box results when the supplier fabricates the box to the allowable outer limits of the nominal dimension.</em></p>
<ul>
<li>加工公差：給定的“盒子”可以指定為公稱尺寸。</li>
</ul>
<p>但是，當供應商按照標準尺寸允許的外部極限來製造盒子時，會導致盒子略大（或更小）。</p>
<ul>
<li><em> Cooling requirements: A certain component may have to be spaced a minimum</em></li>
</ul>
<p><em>distance from another component so that this component is not thermally affected</em></p>
<p><em>to an intolerable extent. In some heat-dissipative situations, components must be</em></p>
<p><em>placed as close as possible (attached to each other).</em></p>
<ul>
<li>冷卻要求：某些組件可能必須與另一個組件的距離是最小間隔，以便該組件不受熱影響，在某些散熱情況下，組件必須盡可能靠近放置（彼此連接）。</li>
</ul>
<ul>
<li><em> Assembly and serviceability requirements: Components may need certain spaces between them due to clearance required to either assemble or disassemble the components.</em></li>
</ul>
<ul>
<li>組裝和維修要求：由於組裝或拆卸組件需要一定間隙，組件之間可能需要保持一定的空間。</li>
</ul>
<ul>
<li><em> Future additions to product (options): Volume may be required for planned additions or product options.</em></li>
</ul>
<p>  •產品（選件)未來的增加：計劃添加或產品選件可能需要數量。</p>
<p><span><em>Looking back at our original intention, to locate an object, 0.100 inch from a wall, we can see that, when we get into the detailed design, we will have to be careful with this 0.100 inch nominal clearance, (shown by the above discussion on tolerances) as this distance can easily “shrink” (in its worst case) from 0.100 inch to 0.100 minus 0.025 (=0.075 inch). Of course, it could be increasing to 0.100 plus 0.025 (=0.125 inch), also. In the “sketch” design phase, we wouldn’t be that concerned with this dimension; again, it would become more important as the design moves to the prototyping phase</em>.</span></p>
<p>回顧我們最初的意圖，即找到距牆壁<span>0.100</span>英寸的物體，當我們進入詳細設計時，我們將必須謹慎對待此<span>0.100</span>英寸的標稱間隙（如以上討論所示） 公差），因為該距離很容易從<span>0.100</span>英寸縮小到<span>0.100-0.025</span>（<span>= 0.075</span>英寸）（在最壞的情況下）。 當然，也可以增加到<span>0.100+0.025</span>（<span>= 0.125</span>英寸）。 在“草圖”設計階段，我們不必擔心這個尺寸； 同樣的，隨著設計進入原型開發階段，這將變得更加重要。</p>
<p><em>All of the above concentration on this 0.100 inch dimension is meant to illustratethat “some distance” is designed between objects (in this case, an object and a wall).</em></p>
<p><em>In most designs, the overall size of the object must be minimized. This leads most designs to have the least possible distance between objects as possible. Examples of designs where overall size (and resulting weight) are minimized would be computer housing, coffee maker, or other household appliance. We live in a world where</em></p>
<p><em>smaller size (usually) equates to:</em></p>
<p><em> </em></p>
<ul>
<li><em> Smaller weight (better fuel savings or ease of use)</em></li>
<li><em> Smaller ecological footprint (savings on materials)</em></li>
<li><em> Saving of space in space-limited situations</em></li>
<li><em> Lower costs (for consumer or producer)</em></li>
</ul>
<p><span> </span></p>
<p>在<span>0.100</span>英寸尺寸上的所有上述集中旨在說明在物體（在這種情況下，是物體和牆壁）之間設計了“一定距離”。</p>
<p>在大多數設計中，必須使物體的整體尺寸最小。 這導致大多數設計在物體之間的距離盡可能小。 使總體尺寸（和所產生的重量）最小化的設計示例包括計算機外殼，咖啡機或其他家用電器。我們生活在一個較小的世界中（通常）是<span>:</span></p>
<p><span> </span></p>
<ul>
<li>重量更輕（更好地節省燃料或易於使用）</li>
<li>較小的生態足跡（節省材料）</li>
<li>在空間有限的情況下節省空間</li>
<li>降低成本（對於消費者或生產者） </li>
</ul>
<p><em>In some cases, it will not be the least possible distance that is desired. Complications such as heat dissipation, or mechanical coupling (say, in a gear drive), certainly affect the distance between objects. We have been “simplifying” the design process in our examples </em></p>
<p>在某些情況下，它不是所需的最小距離。</p>
<p>諸如散熱或機械耦合（例如齒輪傳動）之類的並發症</p>
<p>驅動器），當然會影響物體之間的距離。 我們一直在“簡化”</p>
<p>我們的示例中的設計過程</p>
<p><em>So, for our example of the 0.100 inch distance between the object and the wall, the designer would actually be challenged to determine what minimal distance this could be (e.g., if this distance was 0.050 inch, our overall product could be smaller).</em></p>
<p>因此，對於我們的物體與牆壁之間<span>0.100</span>英寸距離的示例，設計人員實際上將面臨挑戰，以確定這可能是最小的距離（例如，如果該距離為<span>0.050</span>英寸，則我們的整體產品可能會更小）。<span> </span></p>
<p><em>Could this distance shrink even further? (Keep in mind that we came up with an “uncertainty” in this distance in the amount of 0.025 inch.)</em></p>
<p>這個距離會進一步縮小嗎？ （請記住，我們在此距離上產生了<span>0.025</span>英寸的“不確定性”。）</p>
<p><em>In the “sketch phase” of the design, it may not be important to determine this distance exactly. In the interests of proving the overall design in a very quick manner, the designer may make this distance 0.125 inch and get into the details of reducing this distance as the design proves some success. </em></p>
<p>在設計的“草圖階段”，準確確定該距離可能並不重要。 為了以非常快速的方式證明整體設計的利益，設計人員可以使此距離為<span>0.125</span>英寸，並在減小設計距離的細節上獲得成功，因為設計證明是成功的。<span> </span></p>
<p><em>The wall thickness is usually a function of:</em></p>
<ul>
<li><em> Strength required for product operation</em></li>
<li><em> Weight constraints for product</em></li>
<li><em> Fabrication technique</em></li>
</ul>
<p>壁厚通常擁有以下功能的函數：</p>
<ul>
<li>產品操作所需的強度</li>
<li>產品的重量限制</li>
<li>製作工藝</li>
</ul>
<p><em>Wall thickness doesn’t have to be “constant,” that is, it can vary either by the addition of ribs or gussets or the fabrication method that may allow local variation in thickness. </em></p>
<p>壁厚不必“不變”，即可以通過添加肋骨或角撐板或可以允許局部變化的製造方法來變化厚度。<span> </span></p>
<p><span></span></p>
<p><em><strong>2.4.3 Object Arrangement Example (Fig. 2.3) </strong></em></p>
<p><em><strong>2.4.3對象排列示例（圖2.3）</strong></em></p>
<p><em>So far, in our discussion of locating two Objects (a wall and an object), we have been simplifying the discussion with just two dimensions. We will expand into three dimensions in this section. Let’s take our example of Object arrangement a step further. Let’s take a look at several ways to locate two objects inside of an enclosure and see what options we have.</em><span> </span></p>
<p>到目前為止，在我們關於定位兩個物體（一堵牆和一個物體）的討論中，我們僅用二維簡化了討論。 在本節中，我們將擴展為三個維度。 讓我們以“物體排列”為例。 讓我們看一下在機櫃中定位兩個對象的幾種方法，看看我們有哪些選項。<span> </span></p>
<p><em>For the purposes of this example, let’s say that the two Objects are both “bricks” (literally a brick), with the approximate dimensions of:</em></p>
<ul>
<li><em> 2.5 inches thick</em></li>
<li><em> 3.5 inches wide</em></li>
<li><em> 8.0 inches long </em></li>
</ul>
<p>就本示例而言，假設兩個對像都是“磚”（字面上是磚），其近似尺寸為：</p>
<ul>
<li><span>2.5</span>英寸厚</li>
<li><span>3.5</span>英寸寬</li>
<li><span>8.0</span>英寸長 </li>
</ul>
<p><em>In our 2D example, we will forget about the “thickness” and just use the 3.5 × 8.0 width and length dimensions. So, we basically have a rectangle that is 3.5 × 8.0. (We will come back to the 3D example, further on, as this adds more choices for us.) See Fig. 2.3. </em></p>
<p>在我們的<span>2D</span>示例中，我們將忽略“厚度”，而僅使用<span>3.5</span>×<span>8.0</span>的寬度和長度尺寸。 因此，我們基本上有一個<span>3.5</span>×<span>8.0</span>的矩形。 （我們將進一步回到<span>3D</span>示例，因為這為我們添加了更多選擇。）請參見圖<span>2.3</span>。</p>
<p><em>Now, let’s say that our basic starting point in the design is to house two bricks, Brick A and Brick B (both with the same dimensions), in an enclosure. At this initial point, we have no constraints of:</em></p>
<ul>
<li><em> Overall size or shape of enclosure </em></li>
<li><em> Cost of enclosure material</em></li>
</ul>
<p>現在，假設我們設計的基本出發點是將兩個磚塊，磚塊<span>A</span>和磚塊<span>B</span>（尺寸相同）容納在一個封閉空間中。在開始時，我們沒有以下限制：</p>
<ul>
<li>外殼的整體尺寸或形狀</li>
<li>外殼材料成本</li>
</ul>
<p><img alt="" height="845" src="/images/註解 2020-04-11 171014.jpg" width="580"/></p>
<p><em>We can easily envision (at least) five different ways to locate Brick A and Brick B relative to each other, producing very different enclosures. Of course, there are more than five different ways, but I’ve chosen the standard “Cartesian” arrangement of bricks in which they are parallel or aligned to each other. Let’s look at these five different layouts and comment a bit about why one might have some advantages (over the other layouts). A constant one inch is assumed between Brick A and Brick B, and that same one inch clearance is assumed between a brick and a wall (side, top, or bottom). </em></p>
<p>我們可以輕鬆地設想（至少）五種不同的方式來相對於磚塊<span>A</span>和磚塊<span>B</span>定位，從而產生截然不同的外殼。 當然，有超過五種不同的方式，但是我選擇了標準的“笛卡爾”磚排列，其中磚彼此平行或對齊。 讓我們看一下這五個不同的佈局，並評論一下為什麼一個佈局可能比其他佈局更具優勢。 磚塊<span>A</span>和磚塊<span>B</span>之間假定一個恆定的<span>1</span>英寸，磚塊和牆壁（側面，頂部或底部）之間假定一個相同的<span>1</span>英寸間隙。</p>
<ul>
<li><em> Layout 1: Brick A and Brick B side by side along width</em></li>
<li><em> Layout 2: Brick A and Brick B aligned along length</em></li>
<li><em> Layout 3: Brick A and Brick B in “L shape”</em></li>
<li><em> Layout 4: Brick A and Brick B in “T shape”</em></li>
<li><em> Layout 5: Brick A and Brick B “stacked” (a 3D version – this is the only layout that has used the “3rd Dimension”)</em></li>
</ul>
<p><span> </span></p>
<ul>
<li>版式<span>1</span>：沿著寬度並排放置磚塊<span>A</span>和磚塊<span>B</span></li>
<li>佈局<span>2</span>：磚塊<span>A</span>和磚塊<span>B</span>沿長度對齊</li>
<li>佈局<span>3</span>：“<span> L</span>形”的磚塊<span>A</span>和磚塊<span>B</span></li>
<li>版式<span>4</span>：“<span> T</span>形”的磚塊<span>A</span>和磚塊<span>B</span></li>
<li>版式<span>5</span>：“堆疊”磚塊<span>A</span>和磚塊<span>B</span>（<span>3D</span>版本<span>-</span>這是唯一使用“三維”的版式） </li>
</ul>
<p></p>
<p><em>Now, let’s analyze the five layouts. (For all of the layouts, let's assume a very thin-skin for the enclosure that adds essentially zero to the enclosure width, length, and height. Also, we'll neglect the rounded corners that an enclosure might have, and just assume square corners).</em></p>
<p>現在，讓我們分析五種佈局。（對於所有佈局，我們假設外殼的外觀非常薄，實際上使外殼的寬度，長度和高度增加了零。此外，我們將忽略外殼可能具有的圓角，而僅假設方正角落）。</p>
<ul>
<li><em> Layout 1 is seemingly the simplest layout, ending with a relatively square shape</em></li>
</ul>
<p><em>for an enclosure. Resulting enclosure is 10 × 10 × 4.5 high. The six sides (areas) are 2 × (10 × 10) + 4 × (10 × 3.5).</em></p>
<ul>
<li><em> Layout 2 is “long,” rather than “square.” This type of enclosure may have unique applications, such as for better utilization of desk space. Resulting enclosure is 19 × 5.5 × 4.5 high. The six sides (areas) are 2 × (19 × 5.5) + 2 × (19 × 3.5) + 2 × (5.5 × 3.5).</em></li>
<li><em> Layout 3 may be better suited for “corner” applications. Resulting enclosure is (5.5 × 10 × 4.5) + (5.5 × 9 × 4.5). The eight sides (areas) are 3.5 × (4.5 + 9 + 10 + 4.5 + 5.5 + 14.5) + (9 × 5.5 × 2) + (10 × 5.5 × 2).</em></li>
<li><em> Layout 4 is similar to Layout 3 but with a more symmetrical look (same Volume and same perimeter as Layout 3).</em></li>
<li><em> Layout 5 offers minimal “floor plan” but results in the tallest of the layouts. Resulting enclosure is 10 × 5.5 × 8 high. The six sides (areas) are 2 × (10 × 5.5) + 2 × (10 × 8) + 2 × (5.5 × 8).</em></li>
</ul>
<ul>
<li>版式<span>1</span>似乎是最簡單的版式，以相對方形結束</li>
</ul>
<p>用於外殼。所得的機箱高度為<span>10</span>×<span>10</span>×<span>4.5</span>。六個邊（面積）為<span>2</span>×（<span>10</span>×<span>10</span>）<span>+ 4</span>×（<span>10</span>×<span>3.5</span>）。</p>
<ul>
<li>佈局<span>2</span>是“長”，而不是“正方形”。這種類型的外殼可能具有獨特的應用，例如更好地利用辦公桌空間。最終的外殼高度為<span>19</span>×<span>5.5</span>×<span>4.5</span>。六個邊（面積）為<span>2</span>×（<span>19</span>×<span>5.5</span>）<span>+ 2</span>×（<span>19</span>×<span>3.5</span>）<span>+ 2</span>×（<span>5.5</span>×<span>3.5</span>）。</li>
<li>佈局<span>3</span>可能更適合“轉角”應用程序。結果是（<span>5.5</span>×<span>10</span>×<span>4.5</span>）<span>+</span>（<span>5.5</span>×<span>9</span>×<span>4.5</span>）。八個邊（面積）為<span>3.5</span>×（<span>4.5 + 9 + 10 + 4.5 + 5.5 + 14.5</span>）<span>+</span>（<span>9</span>×<span>5.5</span>×<span>2</span>）<span>+</span>（<span>10</span>×<span>5.5</span>×<span>2</span>）。</li>
<li>版面<span>4</span>與版面<span>3</span>相似，但外觀更為對稱（與版面<span>3</span>相同的體積和相同的周長）。</li>
<li>佈局<span>5</span>提供最小的“平面圖”，但導致最高的佈局。最終的外殼高<span>10</span>×<span>5.5</span>×<span>8</span>。六個邊（面積）為<span>2</span>×（<span>10</span>×<span>5.5</span>）<span>+ 2</span>×（<span>10</span>×<span>8</span>）<span>+ 2</span>×（<span>5.5</span>×<span>8</span>）。</li>
</ul>
<p><em>These simple layouts illustrate that even the placement of two Objects, in this case, two bricks, represents quite a few possibilities. If one would add a 3rd Object or Objects of different sizes, one can see that this gets quite complicated. Sometimes, there is a fundamental reason for the placement of one object relative to another, as one object’s “in” should be close to the other object’s “out” (nesting of objects). In any case, let’s continue to discuss some relative merits of the five layouts, above</em>.</p>
<p><span> </span>這些簡單的佈局說明即使放置兩個物體（在這種情況下為兩個磚塊）也代表了很多可能性。如果添加第三個對像或不同大小的對象，您會發現這變得相當複雜。 有時候，一個物體相對於另一個物體的放置是有根本原因的，因為一個物體的“入”應該靠近另一個物體的“出”（嵌套對象）。 無論如何，讓我們繼續討論上面五個佈局的一些相對優點。</p>
<p><span> </span><em>There may be a fundamental aesthetic rationale for a choice between the layouts. That is, Layout 1 could be chosen because it is deemed “more direct” (more “honest”), and it is possible that Layout 3 is deemed more “interesting.” So, the choice of layout could come down to a marketing decision that the customer will find a 2.4 Optimal Object Placement particular enclosure shape to be more pleasing (and, thus, results in higher sales of the product).</em></p>
<p><span> </span><strong>在佈局之間進行選擇可能會有基本的美學原理。 </strong><strong>也就是說，可以選擇佈局<span>1</span></strong><strong>，因為它被認為“更直接”（更“直覺”），並且有可能佈局<span>3</span></strong><strong>被認為更“有趣”。 </strong><strong>因此，佈局的選擇可能取決於市場決定，即客戶會發現<span>2.4</span></strong><strong>最佳對象放置特定的外殼形狀更令人愉悅（並因此提高了產品銷量）。</strong></p>
<p><strong><span> </span></strong><em>How about optimization (minimization) of the surface area of the enclosure – which layouts results in the minimum surface area? Again, the enclosure surrounds both bricks on their sides, top, and bottom.</em></p>
<p><span> </span>如何優化（最小化）外殼的表面積<span>-</span>哪種佈局導致最小的表面積？ 同樣，外殼在其側面，頂部和底部都圍繞著這兩個磚塊。</p>
<p><img alt="" height="216" src="/images/ewrwersd.jpg" width="474"/></p>
<p></p>
<p><span><em>Some Conclusions to Object Arrangemen</em>t</span></p>
<p>關於物體排列的一些結論</p>
<p><span> </span><em>If weight is to be minimized, Layout 1 is best as the weight is primarily due to enclosure perimeter area. (Bricks have the same weight in all layouts, and the air is negligible.)</em></p>
<p><span> </span>如果要使重量最小，則佈局<span>1</span>最好，因為重量主要是由於機櫃的外圍區域。 （磚塊在所有佈局中的重量都相同，空氣可以忽略不計。）</p>
<p><em> If volume is to be minimized, Layout 5 is best. This may be advantageous for some designs where size is restricted.</em></p>
<p><span> </span>如果要最小化體積，則佈局<span>5</span>是最好的。 這對於尺寸受到限制的某些設計可能是有利的。</p>
<p><em> Volume is the same for Layouts 2, 3, and 4</em></p>
<p>佈局<span>2</span>、<span>3</span>和<span>4</span>的體積相同</p>
<p><em> Largest perimeter area is Layout 2. An interesting “Layout 6” (not shown) would be a enclosure that would be a sphere. A 6 inch radius sphere could house Layout 5 with the resulting volume of about 900 cubic inches while only having a perimeter area of about 450 square inches - perhaps a “creative” solution? </em></p>
<p>最大的外圍區域是佈局<span>2</span>。有趣的“佈局<span>6</span>”（未顯示）將是一個球形的外殼。 半徑為<span>6</span>英寸的球體可以容納 佈局<span>5</span>的排列，從而得到大約<span>900</span>立方英寸的體積，而僅具有大約<span>450</span>平方英寸的周長<span>-</span>也許是“創造性”的解決方案？<span> </span></p>
<p><em>Obviously, as more “Objects” are added, it will get more difficult to optimize the objects for volume and perimeter area. The designer’s ingenuity comes with “nesting” various geometrical objects in a given layout area. </em></p>
<p>顯然，隨著添加更多“物體”，優化物體的體積和周邊區域將變得更加困難。 設計師的獨創性是在給定的佈局區域中“嵌套”各種幾何對象。 </p>
<p><em>Various techniques can be used to optimize the layout’s compactness. Once all objects within the enclosure are determined, the designer can model those objects and start placing them in an orientation that:</em></p>
<ol>
<li><em>Utilizes the space in an efficient manner</em></li>
<li><em>. Places objects that require nearness to each other, as closely as possible to each other. This may be due to mechanical, thermal, or electrical reasons to do this. For example, if a cable connects two Objects, it may be advantageous to have these two Objects as close as possible – how about eliminating the cable by connecting (directly) Object 1 into Object 2?</em></li>
<li><span><em>Places objects that need as much distance from each other, as far away as possible from each other. Again, there may be mechanical, thermal, or electrical reasons to do this</em>.</span></li>
</ol>
<p>可以使用各種技術來優化佈局的緊湊性。 一旦確定了機櫃中的所有對象，設計人員就可以對這些對象建模並開始將它們放置在以下方向上：</p>
<p><span>     1.</span>有效利用空間</p>
<p><span>     2.</span>將需要彼此靠近的物體放置在盡可能近的位置。 這可能是由於機械，</p>
<p><span> </span>熱或電氣原因造成的。</p>
<p>例如，如果電纜連接兩個對象，則使這兩個對象盡可能靠近可能是有利的–通過將對象<span>1</span>（直接）連接到對象<span>2</span>來消除電纜怎麼樣？</p>
<p><span>     3.</span>放置需要彼此盡可能遠的對象，並使其盡可能遠。 同樣，可能出於機械，熱或電氣方面的原因。</p>
<p><em>It should be noted that Layout 3 and Layout 4 could be more complicated to produce (manufacture). The nonsymmetrical enclosure could be more difficult to fabricate than straight walls. This is not necessarily so if theenclosure is a tooled (molded or cast) product. However, if the enclosure is sheet metal, the extra walls provide a bit more of an issue to fabricate.</em></p>
<p>應該注意的是，佈局<span>3</span>和佈局<span>4</span>的生產（製造）可能更加複雜。 非對稱外殼可能比直壁更難製造。 如果外殼是加工（模製或鑄造）產品，則不一定如此。 但是，如果外殼是金屬板，則多餘的壁增加了更多的製造問題。</p>
<p><em>A note about designing in 3D: As all of the objects we design are actually 3Dobjects, we will actually need to design in 3D. A quick sketch in 2D may solve a portion of the design intent, but all of the details will need to be shown as the design moves to 3D. </em></p>
<p>關於<span>3D</span>設計的注意事項：由於我們設計的所有物體實際上都是<span>3D</span>物體，因此實際上我們需要進行<span>3D</span>設計。 快速的<span>2D</span>草圖可以解決部分設計意圖，但是在設計移至<span>3D</span>時需要顯示所有細節。</p>
<p><em>This makes working in CAD essential to the accuracies and speed required in the contemporary design world. Creating 3D models of all of the objects makes checking clearances and fits simple to change and optimize.</em></p>
<p><span> </span>這使得在<span>CAD</span>中工作對於精度和速度至關重要</p>
<p>在當代設計界是必需的。 通過創建所有對象的<span>3D</span>模型，可以檢查間隙並使其易於更改和優化。<span> </span></p>
<p><em>An example of this is how a mechanical designer views a printed circuit board assembly (PCBA). </em></p>
<p>機械設計師如何看待印刷電路板組件（<span>PCBA</span>）就是一個例子。</p>
<p><em> this is how a mechanical designer views a printed circuit board assembly (PCBA). It basically has a 2D layout of many components mounted on a printed circuit board. However, all of those components are at various heights, thus clearances above and below the PCBA will vary in many areas. Thus, the PCBA, while primarily thought of as a “2D area” (in the “sketch phase”), has a “thickness” to it that makes it a 3D volume.</em></p>
<p><span> </span>這就是機械設計師如何看待印刷電路板組件（<span>PCBA</span>）的方式。 它基本上具有安裝在印刷電路板上的許多組件的<span>2D</span>佈局。 但是，所有這些組件都處於不同的高度，因此<span>PCBA</span>上方和下方的間隙在許多區域會有所不同。 因此，<span>PCBA</span>雖然最初被認為是“<span> 2D</span>區域”（處於“草圖階段”），但其如果具有“厚度”，使其成為<span>3D</span>體積。</p>
<p><span> </span></p>
<p></p>
<p><span> </span></p>
<p><em><strong>Chapter Summary</strong></em></p>
<p><em><strong>章節總結</strong></em></p>
<p><em><strong> </strong>This chapter takes us from the beginning point of a design where we have just an idea. It shows us how we transform that idea into the geometric placement of objects into space that gives us a physical manifestation of that idea.</em></p>
<p><span> </span>本章將我們帶入一個只有想法的設計的起點。 它向我們展示瞭如何將這個想法轉變為物體在空間中的幾何放置，從而使我們對該想法進行物理表現。</p>
<p><em>We started by looking at our starting point and defining the boundaries of the design – what do we start with and what is the “outer edge” of the design. We have to define what the product is that the customer will need.</em></p>
<p>首先，我們著眼於起點並定義設計的邊界<span>-</span>我們從什麼開始，什麼是設計的“外緣”。 我們必須定義客戶所需的產品。我們看到了設計從修訂版<span>1</span>到修訂版<span>X</span>的過程，其中<span>X</span>是提供我們認為是客戶所需的設計。</p>
<p><em>Finally, we took a look at seeing how the individual objects that need to be in the design can be optimally placed to solve customer needs. There are trade-offs to be considered, and we must be aware of how we determine the best choices between these trade-offs.</em></p>
<p>最後，我們看了看如何最佳放置設計中需要解決的單個物體來滿足客戶需求。 需要權衡取捨，我們必須意識到我們如何決定這些權衡之間的最佳選擇。</p>
<div id="gtx-trans" style="position: absolute; left: -4px; top: 66px;">
<div class="gtx-trans-icon"></div>
</div><h1>小組直播討論</h1>
<p>week3</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/c06esX1zO90" width="560"></iframe></p>
<p>week4</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/lObYwRDd4Ro" width="560"></iframe></p>